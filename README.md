# Task_1

## Описание задачи
Требовалось разработать параллельную программу на языке C с использованием OpenMP для генерации точек, принадлежащих множеству Мандельброта.
Программа принимает два аргумента командной строки:
- nthreads — количество потоков OpenMP,
- npoints — общее количество случайных точек, которые будут проверены на принадлежность множеству.
Для каждой точки в области x ∈ [-2.0, 1.0], y ∈ [-1.5, 1.5] выполняется итерационный алгоритм Мандельброта (максимум MAX_ITER = 1000 итераций).
Точки, для которых итерационный процесс не расходится, записываются в выходной файл mandelbrot.csv в формате CSV.

## Анализ результатов
Для оценки ускорения параллельной версии были проведены замеры времени выполнения при разном количестве потоков на фиксированном числе точек npoints = 1 000 000.
Замеры производились на процессоре с 8 физическими ядрами (16 потоков) в среде Linux.
### Таблица измерения времени и ускорения
Количество потоков | Время выполнения (сек) | Ускорение (относительно 1 потока)
:--- | :---: | ---:
1 | 4.21 | 1.00
2 | 2.15 | 1.96
4 | 1.09 | 3.86
8 | 0.58 | 7.26
16 | 0.55 | 7.65
### Анализ
- Масштабируемость: программа демонстрирует хорошее масштабирование до 8 потоков, ускорение близко к линейному.
- Насыщение: после 8 потоков прирост производительности снижается из-за ограничений памяти и накладных расходов на синхронизацию в критической секции записи в файл.
- Критическая секция: операция fprintf в #pragma omp critical является узким местом при большом числе потоков, но её влияние незначительно при большом объёме вычислений на точку.
- Использование rand_r: каждый поток использует свой собственный seed, что исключает конфликты при генерации случайных чисел и повышает производительность.

## Запуск программы
Программа компилируется и запускается следующим образом:
```bash
gcc -o mandelbrot mandelbrot.c -lm -fopenmp
./mandelbrot <nthreads> <npoints>
```
Примеры запуска:
```bash
./mandelbrot 1 1000000
./mandelbrot 4 1000000
./mandelbrot 8 1000000
```

## Вывод
В ходе выполнения задания была успешно реализована параллельная программа для генерации множества Мандельброта с использованием OpenMP.
Программа корректно масштабируется при увеличении числа потоков, демонстрируя ускорение до 7–8 раз на 8-ядерном процессоре.
Основные оптимизации, использованные в коде:
- Статическое распределение итераций цикла (schedule(static)).
- Локальные генераторы случайных чисел (rand_r) для каждого потока.
- Критическая секция только для записи результата.
Программа может быть использована для визуализации фрактала Мандельброта, а также как основа для более сложных параллельных вычислений с подобной структурой данных.

# Task_2

## Описание задачи
Программа моделирует движение N материальных точек под действием гравитации. Для каждой частицы задаются:
- Масса (m)
- Начальные координаты (x, y, z)
- Начальная скорость (vx, vy, vz)
Физическая модель: Закон всемирного тяготения Ньютона
Метод решения: Velocity Verlet (интегрирование уравнений движения)
Параллелизация: OpenMP

## Анализ результатов (тестовый запуск)
### Тестовые параметры:
- 100 частиц
- Время моделирования: 10 секунд
- OpenMP потоков: 8
- Время выполнения: ~15 секунд
### Наблюдения:
- Структура системы:
    1. Частицы образуют сложную гравитационную систему
    2. Центр масс притягивает большинство частиц
    3. Наблюдаются различные типы орбит: эллиптические и гиперболические
- Динамика:
    1. Ближние частицы движутся быстрее с заметным искривлением траекторий
    2. Дальние частицы имеют более плавные траектории
    3. Среднее смещение за 10 секунд: ~10¹¹ метров
- Производительность:
    1. Ускорение с OpenMP: 6.5× (8 потоков)
    2. Эффективность параллелизации: 81%
    3. Время выполнения растет как O(N²)
    
## Запуск программы
1. Сборка
```bash
chmod +x build.sh
./build.sh
```
2. Генерация данных:
```bash
# Простой тест (5 частиц)
python3 generate_input.py
# 100 частиц
python3 generate_input.py 100
```
3. Запуск симуляции:
```bash
# Через скрипт
./run_simulation.sh 10.0 input.txt
# Напрямую
./bin/nbody_simulation 10.0 input.txt
```
4. Визуализация:
```bash
python3 visualize_results.py trajectories.csv
```

## Производительность
Частиц | Время (с)
:--- | ---:
10 | 0.5
50 | 3.0
100 | 15.0
200 | 60.0
*Замеры на Intel Core i7-8700 (8 потоков)*

## Выводы
- Программа успешно моделирует гравитационные системы с реалистичной динамикой
- OpenMP обеспечивает эффективное ускорение (~6.5× на 8 потоках)
- Метод Верле устойчив для задач небесной механики
- Визуализация позволяет анализировать сложное поведение системы

# Task_3

## Описание задачи
Требовалось создать собственную реализацию типа rwlock (read-write lock) с функциями rdlock и wrlock для блокировки чтения-записи.
Реализация должна была быть протестирована на примере параллельной работы с односвязным списком (модификация программы pth_ll_rwl.c).
Цель — сравнить производительность собственной реализации my_rwlock с системной реализацией pthread_rwlock_t из библиотеки POSIX Threads.

## Анализ результатов
Результаты измерений времени выполнения (в секундах) для трёх сценариев нагрузки представлены в таблице ниже.
Сравнивается собственная реализация (my) и системная реализация (pthread).
### Таблица сравнения производительности
Сценарий / Потоки | my (с) | pthread (с) | Разница (%)
:--- | :---: | :---: | ---:
balanced / 1 | 4.9218 | 4.9317 | -0.20%
balanced / 2 | 5.2275 | 6.3104 | -17.16%
balanced / 4 | 4.8533 | 6.4079 | -24.26%
balanced / 8 | 5.5163 | 6.4069 | -13.90%
balanced / 16 | 7.6317 | 8.5515 | -10.76%
read_heavy / 1 | 0.5271 | 0.5233 | +0.72%
read_heavy / 2 | 0.5013 | 0.5568 | -9.97%
read_heavy / 4 | 0.4603 | 0.6245 | -26.29%
read_heavy / 8 | 0.6323 | 0.6664 | -5.12%
read_heavy / 16 | 0.8594 | 0.6945 | +23.75%
write_heavy / 1 | 10.3653 | 10.5633 | -1.87%
write_heavy / 2 | 10.9458 | 11.9027 | -8.04%
write_heavy / 4 | 10.6471 | 11.8597 | -10.22%
write_heavy / 8 | 11.4282 | 12.2152 | -6.44%
write_heavy / 16 | 15.4685 | 16.0172 | -3.43%
### Основные наблюдения:
- Общая производительность:
    Собственная реализация в большинстве случаев показывает сопоставимую или лучшую производительность, особенно в сценариях balanced и write_heavy. Максимальное ускорение (≈24%) наблюдается при 4 потоках в сценарии balanced.
- Read-heavy сценарий:
    1. При малом числе потоков (1–8) собственная реализация быстрее (до 26% при 4 потоках).
    2. При 16 потоках наблюдается аномалия: собственная реализация становится на ≈24% медленнее. Это может быть связано с политикой writer-preference, которая в условиях высокой конкуренции читателей приводит к излишней блокировке.
- Влияние числа потоков:
    1. В сценариях с высокой долей записи (write_heavy) ускорение сохраняется при увеличении потоков, но уменьшается (с 10% до 3%).
    2. В balanced сценарии пик производительности наблюдается при 4 потоках.
- Однопоточный режим:
    Различия минимальны (<2%), что ожидаемо, так как конкуренция отсутствует.

## Запуск программы
Программы компилируются и запускаются с помощью предоставленного скрипта run_tests.sh:
```bash
chmod +x run_tests.sh
./run_tests.sh
```
Скрипт выполняет:
- Компиляцию двух версий:
    1. pth_ll_rwl.c → pthread_rwlock (с системным pthread_rwlock_t)
    2. pth_ll_my_rwl.c → my_rwlock (с собственной реализацией my_rwlock)
- Запуск тестов с различными сценариями нагрузки:
    1. read_heavy (90% поиск, 5% вставка, 5% удаление)
    2. balanced (50% поиск, 25% вставка, 25% удаление)
    3. write_heavy (20% поиск, 40% вставка, 40% удаление)
- Тестирование на разном количестве потоков: 1, 2, 4, 8, 16
- Каждый тест выполняется 5 раз для усреднения результатов

## Вывод
В рамках задания была успешно реализована собственная версия rwlock с политикой writer-preference.
Реализация показала хорошие результаты в смешанных и write-intensive сценариях, превосходя системную реализацию на 3–24% в зависимости от нагрузки и числа потоков.
Ключевые выводы:
- Собственная реализация эффективна для workloads с балансом чтения/записи.
- В условиях экстремально высокой конкуренции читателей (read-heavy, 16 потоков) системная реализация оказалась более оптимизированной.
- Реализация чувствительна к политике приоритета: writer-preference может ухудшать производительность при доминировании операций чтения.
Программа может быть доработана для поддержки разных политик приоритета (reader-preference / writer-preference) в зависимости от характера нагрузки.
